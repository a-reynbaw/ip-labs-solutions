#include <stdio.h>

/*
    Η badf δεν δουλεύει για τον εξής λόγο:
    Όταν καλούμε μία συνάρτηση, η συνάρτηση θα δημιουργήσει αντίγραφα
    των μεταβλητών που θα στείλουμε. Δηλαδή, θα φτιάξει αντίγραφο για τις
    a, b, sum & diff με διαφορετικές διευθύνσεις μνήμης. Άρα, η συνάρτηση αυτή θα επεξεργαστεί τα αντίγραφα
    και όχι τις μεταβλητές που στέλνουμε!

    Πως λύνεται αυτό το πρόβλημα; Pointers!
    Στέλνοντας την διεύθυνση της μεταβλητής όταν καλούμε την συνάρτηση (πχ γράφοντας f(&x)), το αντίγραφο δεν θα έχε νόημα,
    καθώς θα έχει την ίδια διεύθυνση. Στην ίδια την συνάρτηση, αντιμετωπίζουμε την συνάρτηση ως έναν απλό δείκτη 
    (στο ίδιο παράδειγμα, το x θα αντιμετωπίζεται έτσι: *x).
*/
void badf(int x, int y, int sum, int diff)
{
    sum = x + y;
    diff = x - y;
}

void goodf(int x, int y, int *sum, int *diff)   // μπορούμε και τα x, y να τα αντιμετωπίσουμε σαν pointers, αλλά δεν μας βοηθάει κάπου σχετικά με την ορθότητα της άσκησης.
{
    *sum = x + y;
    *diff = x - y;
}

int main(void)
{
    int a, b, sum = 0, diff = 0;

    scanf("%d %d", &a, &b);

    badf(a, b, sum, diff);
    printf("%d %d\n", sum, diff);

    goodf(a, b, &sum, &diff);
    printf("%d %d\n", sum, diff);

    return 0;
}