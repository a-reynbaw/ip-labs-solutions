/*  
    κάνουμε compile γράφοντας στο terminal: gcc -o ex2_3 ex2_3.c
    τρέχουμε το πρόγραμμα μας γράφοντας στο terminal: ./ex2_3
*/

/*
    Σημαντική σημείωση:
    Υπάρχει ένα πανίσχυρο προγραμματιστικό εργαλείο που ονομάζεται αναδρομή.
    Η αναδρομή χοντρικά χαρακτηρίζεται από την παρακάτω λειτουργία:
    Όπως η main μπορεί να καλέσει μία συνάρτηση έτσι η αναδρομική συνάρτηση
    καλεί μία συνάρτηση, η οποία είναι ο εαυτός της!
    Μία ιδιαιτέρως γνωστή αναδρομική συνάρτηση, είναι η Fibonacci (https://el.wikipedia.org/wiki/%CE%91%CE%BA%CE%BF%CE%BB%CE%BF%CF%85%CE%B8%CE%AF%CE%B1_%CE%A6%CE%B9%CE%BC%CF%80%CE%BF%CE%BD%CE%AC%CF%84%CF%83%CE%B9).
    Μία αναδρομική συνάρτηση, μπορεί ορισμένες φορές να αντικαταστήσει πλήρως μια επαναληπτική διαδικασία.

    Μία απλή αναδρομική συνάρτηση οργανώνεται ως εξής:
    1) base case, η απλή περίπτωση που μπορούμε να ελέγξουμε. Για παράδειγμα, στην Fibonacci θα κάναμε το εξής:
    
    if (n == 0)
        return 0;
    else if (n == 1)
        return 1;

    2) το "βήμα", σε αυτό το σημείο καλεί η συνάρτηση τον εαυτό της. Στην Fibonacci θα συνεχίζαμε τον κώδικα μας κάπως έτσι:

    return f(n - 1) + f(n - 2);

    Ορίστε ο αλγόριθμος ολοκληρωμένος:

    int fibonacci(int n)
    {
        if (n == 0)
            return 0;
        else if (n == 1)
            return 1;
        else 
            return fibonacci(n - 1) + fibonacci(n - 2);
    }
*/

#include <stdio.h>

/*  
    μία ενδιαφέρουσα βιβλιοθήκη που μας βοηθάει να γράψουμε γρήγορα και ξεκάραθα μερικούς τύπους, για παράδειγμα,
    αντί για unsigned long μπορούμε να γράψουμε uint64_t.
*/
#include <stdint.h>

uint64_t collatz(uint64_t n)
{
    /* base case, ξέρουμε ότι όταν το n είναι 1 επιστρέφουμε 1 */
    if (n == 1)
        return 1;

    /* Βήμα, πρέπει να καλέσουμε αναδρομικά την collatz με το κατάλληλο n */
    if (n % 2 == 0)
        n /= 2;
    else
        n = 3 * n + 1;

    return collatz(n) + 1;
}

int main()
{
    printf("The number of terms of the collatz sequence is: %ld\n", collatz(22));   /* 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1 -> 16 */
    return 0;
}